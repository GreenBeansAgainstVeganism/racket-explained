<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto%20Slab:400,700">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto%20Mono:400,700">
    <link rel="shortcut icon" href="./assets/favicon.png" type="image/x-icon">
    <script src="./scripts/script.js"></script>
    <title>Racket Explained | Common Functions</title>
</head>

<body>
    <header>
        <a href="index.html"><img id="logo" src="./assets/logo.png" width="103" height="103" alt="Racket Logo"></a>
        <h1>
            <a href="index.html">
                Racket Explained
            </a>
        </h1>
        <p>A reference guide and FAQ for CSCI 301 students.</p>
    </header>
    <nav id="nav-menu">
        <h2>Links</h2>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="faq.html">Racket FAQ</a></li>
            <li><a class="active" href="functionguide.html">Common Functions</a></li>
            <li><a href="formatter.html">Bracket Helper</a></li>
            <li><a href="resources.html">Other Resources</a></li>
        </ul>
    </nav>
    <button id="nav-button" onclick="this.classList.toggle('open');document.getElementById('nav-menu').classList.toggle('open');"></button>
    <main>
        <h2>Common Function Guide</h2>
        <p>Here you will find detailed walkthroughs of how to use several of the most confusing <span class="linkgen">Racket</span> functions that are commonly used in assignments. This will by no means be a comprehensive list of all functions, so if the function you're looking for is not here, the <a href="https://docs.racket-lang.org/search/index.html">Racket Docs</a> entry for it is probably sufficient or it's not relevant to your classwork.</p>
        <h3>
            Quick Reference Table: (Alphabetical)
        </h3>
        <table>
            <tr>
                <th style="width:15%">Function</th>
                <th style="width:15%">Return Type</th>
                <th>Short Description</th>
            </tr>
            <tr>
                <td><span class="linkgen">curry</span></td>
                <td><span class="linkgen">proc</span></td>
                <td>Modifies a given procedure to be able to continuously consume parameters until it has enough rather than requiring them all at once.</td>
            </tr>
            <tr>
                <td><span class="linkgen">define</span></td>
                <td><span class="linkgen">any</span></td>
                <td><span class="linkgen">Binds</span> an identifier to a value, or a procedure.</td>
            </tr>
            <tr>
                <td><span class="linkgen">lambda</span></td>
                <td><span class="linkgen">proc</span></td>
                <td>Returns a new <span class="linkgen">procedure</span> with a specified set of parameters and body.</td>
            </tr>
            <tr>
                <td><span class="linkgen">map</span></td>
                <td><span class="linkgen">list</span></td>
                <td>Runs every member of a list (or set of members from a set of lists) through a given procedure and returns the list of results.</td>
            </tr>
            <tr>
                <td><span class="linkgen">andmap</span></td>
                <td><span class="linkgen">any</span></td>
                <td>Runs every member of a list (or set of members from a set of lists) through a given procedure and returns the logical AND of all of the results together.</td>
            </tr>
            <tr>
                <td><span class="linkgen">ormap</span></td>
                <td><span class="linkgen">any</span></td>
                <td>Runs every member of a list (or set of members from a set of lists) through a given procedure or returns the logical OR of all of the results together.</td>
            </tr>
        </table>
        <h2>Detailed Descriptions:</h2><br>
        <h3 id="func-lambda">lambda</h3>
        <section>
            
            <pre><code>(lambda (<i>args</i>) <i>body</i> ...)</code></pre>

            <a class="docs-link" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29"></a>
            <h4>Main Overview</h4>
            <p>
                The lambda function is often people's first experience with <span class="linkgen">procedures</span>, that is, functions as data values. The name, lambda, comes from the <strong>Lambda Calculus</strong>, which is the formal mathematical system which inspired the whole <span class="linkgen">Lisp</span> family of programming languages.
            </p>
            <p>
                The lambda function is used to create a new procedure. The first parameter, <code>args</code> holds the names of the parameters that the procedure should accept. The second parameter, <code>body</code> holds the expression that the procedure should evaluate.
            </p>

            <figure>
                <pre><code><span class="comment">; Procedure which adds 5 to a value</span>
(lambda (x) (+ x 5)) <span class="note">-&gt; #&lt;procedure&gt;</span>

<span class="comment">; Procedure which takes the average of 2 numbers</span>
(lambda (a b) (/ (+ a b) 2)) <span class="note">-&gt; #&lt;procedure&gt;</span>

<span class="comment">; Applying a procedure immediately after creation with lambda</span>
(<span class="highlight">(lambda (x) (+ x 5))</span> 8) <span class="note">-&gt; 13</span>

<span class="comment">; Passing a procedure made with lambda as a parameter to another procedure</span>
(<span class="linkgen">map</span> <span class="highlight">(lambda (x) (+ x 5))</span> '(1 2 3 4)) <span class="note">-&gt; '(6 7 8 9)</span></code></pre>
            </figure>

            <h4>Optional Parameters</h4>
            <p>
                You can assign default values to parameters, which gives the user the option to skip passing in a value for that parameter. The parameter will then be filled in with whatever the default value is. The syntax looks like this:
            </p>

            <pre><code><span class="comment">; Procedure with one required parameter and one optional parameter</span>
(lambda (x [y 5]) (+ x y))

<span class="comment">; Applying that procedure without specifying a value for y</span>
(<span class="highlight">(lambda (x [y 5]) (+ x y))</span> 11) <span class="note">-> 16</span></code></pre>
            
            <p>
                Note that you must put all optional parameters at the end of your parameter list, after all required parameters, so that the order that parameters are passed in is always clear.
            </p>

            <figure>
                <pre><code><span class="comment">; Optional parameter before required parameter</span>
(lambda (x <span class="highlight">[y 5] z</span>) (+ x (+ y z))) <span class="error">-> SYNTAX ERROR</span></code></pre>
                <figcaption>What would happen if you called this procedure with 2 parameters? The program could eventually figure out that you meant to pass those values to x and z, but this gets less and less obvious to compute with bigger and more complicated arrangements. It's much more efficient to just have the restriction that all optional parameters come last.</figcaption>
            </figure>

            <h4>Trailing Bodies</h4>
            <p>
                If you have keen eyes you may have noticed the <code>...</code> in the definition of lambda and been wondering what that's all about. Well, as with most places that accept a code body, lambda will accept as many body expressions as you give it. These bodies will be executed one after another, and as is standard for Racket, the <em>last</em> body expression to be evaluated (also called <strong>tail position</strong>) will be the one that supplies the return value for the whole procedure.
            </p>

            <pre><code>(<span class="highlight">(lambda (x y) (println x) (println y) (+ x y))</span> 4 5)
<span class="output">&gt; 4&NewLine;&gt; 5</span>
<span class="note">-&gt; 9</span></code></pre>
            
        </section>
        <hr>
        <h3 id="func-define">define</h3>
        <section>

            <pre><code>(define <em>id</em> <em>expr</em>)
(define (<em>head</em> <em>args</em>) <em>body</em> ...)</code></pre>

            <a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="docs-link"></a>
            <h4>Main Overview</h4>
            <p>
                You can think of the define function as <span class="linkgen">Racket</span>'s version of a global variable/function definition. Define is one of the few functions which does not have a return value. Instead, it is used to <span class="linkgen">bind</span> an identifier <code>id</code> to a value <code>expr</code>. Once bound, you'll be able to refer to that value later in your program using the name that it was bound to, just like when you define a variable in Java or C.
            </p>

            <figure>
                <pre><code>(define myvariable 8)

(println myvariable)
<span class="output">&gt; 8</span></code></pre>
            </figure>

            <p>
                Of course, with the help of <span class="linkgen">lambda</span> or any other function that returns a <span class="linkgen">procedure</span>, you can also define functions this way! However, define also has an alternate syntax that is specifically for defining functions, which is kind of like a define and lambda combined. Instead of <code>id</code>, you specify the form that is to be used when calling the function, including its name and parameters. Then, as the second parameter you supply the body of the function. Below are examples of the same function being defined in Java syntax as well as both Racket syntaxes, for clarity:
            </p>

            <figure>
                <pre><code><span class="comment">// in Java</span>
public static var computeAverage(var x, var y)
{
    return (x + y) / 2.0;
}

<hr>
<span class="comment">; in Racket, with lambda</span>
(define compute-average <span class="highlight">(<span class="linkgen">lambda</span> (x y) (/ (+ x y) 2))</span>)

<span class="comment">; in Racket, with alternate define syntax</span>
(define (compute-average x y) (/ (+ x y) 2))</code></pre>
            </figure>

            <h4>Nested Function Definition</h4>
            <p>The alternate syntax of define has a bonus feature that may occasionally be useful if you can wrap your head around it. That is the ability to define <strong>nested functions</strong>. </p>

            <figure>
                <pre><code>(define ((increase-by x) y) (+ y x))

((increase-by 5) 4) <span class="note">-&gt; 9</span></code></pre>
            </figure>

            <p>
                To better understand what's going on, let's take another look at the define alternate syntax:
            </p>

            <figure>
                <pre><code>(define (<em>head</em> <em>args</em>) <em>body</em> ...)</code></pre>
            </figure>

            <p>
                What I neglected to point out before is that the <code>head</code> part of this definition is actually recursive. That is, you can replace <code>head</code> with another <code>(head args)</code> as many times as you want and the syntax will still be valid.
            </p>

            <figure>
                <pre><code>(define ((<em>head</em> <em>args</em>) <em>args</em>) <em>body</em> ...)
(define (((<em>head</em> <em>args</em>) <em>args</em>) <em>args</em>) <em>body</em> ...)
(define ((((<em>head</em> <em>args</em>) <em>args</em>) <em>args</em>) <em>args</em>) <em>body</em> ...)
...
in general:
<em>head</em> -> (<em>head</em> <em>args</em>) or <em>id</em></code></pre>
                <figcaption>If you're further along in your course, you may recognize that last line as a production rule for a context-free grammar.</figcaption>
            </figure>

            <p>
                What does this do though? Well, what's happening is it's defining a function which returns another function, which finally returns a value. It's as if the function <code>(increase-by x)</code> itself is the name of the main function <code>((increase-by x) y)</code>.
            </p>
            <p>
                This is all still just shorthand; it's nothing you couldn't achieve with the basic define syntax and some lambdas, as you can see demonstrated below:
            </p>

            <figure>
                <pre><code>; Function from the earlier example
(define ((increase-by x) y) (+ y x))

; The same function defined with basic syntax
(define increase-by (<span class="linkgen">lambda</span> (x) <span class="highlight">(<span class="linkgen">lambda</span> (y) (+ y x))</span>))</code></pre>
                <figcaption>Notice, the first lambda returns a second lambda!</figcaption>
            </figure>

            <p>
                Why would we want this? Well, the first syntax up above is much shorter and also clearer about the usage of the function that we're defining. As for why we'd want a nested function like that, there are times when we'd like to define a whole set of related functions, such as <code>increase-by-1</code>, <code>increase-by-10</code>, <code>increase-by-100</code> and this can be a neat and scalable way of doing so.
            </p>

            <figure>
                <pre><code>(define ((increase-by x) y) (+ y x))

(define (increase-by-1 y) (increase-by 1))
(define (increase-by-10 y) (increase-by 10))
(define (increase-by-100 y) (increase-by 100))

(println (increase-by-100 (increase-by-10 4)))
<span class="output">&gt; 114</span></code></pre>
                <figcaption>Of course, this is a pretty silly example since it would be easier just to use the built in <code>+</code> function, but imagine that the task we're trying to accomplish is a little more complex, like matrix multiplication. It would be convenient to just create a function that multiplies by a particular matrix if we know we're going to be doing it a lot. An alternative approach is to use <span class="linkgen">curry</span>.</figcaption>
            </figure>
        </section>
        <hr>
        <h3 id="func-map">map</h3>
        <section>
            <figure>
                <pre><code>(map proc lst ...)</code></pre>
            </figure>
            <a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="docs-link"></a>
            <h4>Main Overview</h4>

        </section>
        <hr>
        <h3 id="func-curry">curry</h3>
        <section>
            <figure>
                <pre><code>(curry proc)
(curry proc v ...)</code></pre>
            </figure>
            <a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._curry%29%29" class="docs-link"></a>
            <h4>Main Overview</h4>
            <p>
                Currying is one of the more advanced standard operations in <span class="linkgen">functional programming</span> and it's named after mathematician Haskell Curry (who also has 3 different programming languages named after him). It describes the process of breaking down a procedure so that parameters can be fed to it one by one rather than all at once.
            </p>
            <p>
                When you call <code>curry</code> on a procedure, it returns a <em>curried</em> version of that procedure, which will behave exactly like the original procedure if it is called with the required number of parameters.
            </p>

            <figure>
                <pre><code>cons <span class="note">-&gt; #&lt;procedure:cons&gt;</span>

(curry cons) <span class="note">-&gt; #&lt;procedure:curried:cons&gt;</span>

(cons 2 &apos;(6)) <span class="note">-&gt; &apos;(2 6)</span>

((curry cons) 2 &apos;(6)) <span class="note">-&gt; &apos;(2 6)</span></code></pre>
            </figure>

            <p>
                However, if you feed a curried procedure <em>fewer</em> parameters than it requires, it will <em>wait</em>, returning itself (to be precise, a version of itself that remembers the parameters you passed) until it recieves enough parameters, at which point it will finally execute.
            </p>

            <figure>
                <pre><code>((curry cons) 2) <span class="note">-&gt; #&lt;procedure:curried:cons&gt;</span>

(<span class="highlight">((curry cons) 2)</span> &apos;(6)) <span class="note">-&gt; &apos;(2 6)</span></code></pre>
            </figure>
        </section><hr>
        <h3 id="func-andmap">andmap | ormap</h3>
        <section>
            <figure>
                <pre><code>(andmap <em>proc</em> <em>lst</em> ...)
(ormap <em>proc</em> <em>lst</em> ...)</code></pre>
            </figure>
        </section>
    </main>
    <footer>
        <h2>Racket Explained</h2>
        <h3>References:</h3>
        <ul>
            <li>
                Graham, Hutton. "Frequently Asked Questions for comp.lang.functional". <a href="http://www.cs.nott.ac.uk/~pszgmh/faq.html">http://www.cs.nott.ac.uk/~pszgmh/faq.html</a>
            </li>
            <li>
                Official Racket Documentation. <a href="https://docs.racket-lang.org/">https://docs.racket-lang.org/</a>
            </li>
            <li>
                Lisp Programming Language Guide - History-Computer. <a href="https://history-computer.com/lisp-programming-language-guide/">https://history-computer.com/lisp-programming-language-guide/</a>
            </li>
        </ul>
    </footer>
</body>

</html>