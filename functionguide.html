<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="format-detection" content="telephone=no">
    <link rel="stylesheet" href="./css/style.css">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto%20Slab:400,700">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto%20Mono:400,700">
    <link rel="shortcut icon" href="./assets/favicon.png" type="image/x-icon">
    <script src="./scripts/script.js"></script>
    <title>Racket Explained | Common Functions</title>
</head>

<body>
    <header>
        <a href="index.html"><img id="logo" src="./assets/logo.png" width="103" height="103" alt="Racket Logo"></a>
        <h1>
            <a href="index.html">
                Racket Explained
            </a>
        </h1>
        <p>A reference guide and FAQ for CSCI 301 students.</p>
    </header>
    <nav id="nav-menu">
        <h2>Links</h2>
        <ul>
            <li><a href="index.html">Home</a></li>
            <li><a href="faq.html">Racket FAQ</a></li>
            <li><a class="active" href="functionguide.html">Common Functions</a></li>
            <li><a href="formatter.html">Bracket Helper</a></li>
            <li><a href="resources.html">Other Resources</a></li>
        </ul>
    </nav>
    <button id="nav-button" onclick="this.classList.toggle('open');document.getElementById('nav-menu').classList.toggle('open');"></button>
    <div class="zero-height">
        <nav id="page-nav-menu">
            <h2 id="page-nav-title"></h2>
            <ul id="page-nav-links">
                <li><strong><a href="#">Top</a></strong></li>
            </ul>
        </nav>
    </div>
    <main id="content">
        <h2>Common Function Guide</h2>
        <p>Here you will find detailed walkthroughs of how to use several of the most confusing <span class="linkgen">Racket</span> functions that are commonly used in assignments. This will by no means be a comprehensive list of all functions, so if the function you're looking for is not here, the <a href="https://docs.racket-lang.org/search/index.html">Racket Docs</a> entry for it is probably sufficient or it's not relevant to your classwork.</p>
        <h3 id="reference-table">
            Quick Reference Table: (Alphabetical)
        </h3>
        <table>
            <tr>
                <th style="width:15%">Function</th>
                <th style="width:15%">Return Type</th>
                <th>Short Description</th>
            </tr>
            <tr>
                <td><span class="linkgen">andmap</span></td>
                <td><span class="linkgen">any</span></td>
                <td>Runs every member of a list (or set of members from a set of lists) through a given procedure and returns the logical AND of all of the results together.</td>
            </tr>
            <tr>
                <td><span class="linkgen">cons</span></td>
                <td><span class="linkgen">pair</span></td>
                <td>Creates a new pair out of its two parameters.</td>
            </tr>
            <tr>
                <td><span class="linkgen">curry</span></td>
                <td><span class="linkgen">proc</span></td>
                <td>Modifies a given procedure to be able to continuously consume parameters until it has enough rather than requiring them all at once.</td>
            </tr>
            <tr>
                <td><span class="linkgen">define</span></td>
                <td><span class="linkgen">any</span></td>
                <td><span class="linkgen">Binds</span> an identifier to a value, or a procedure.</td>
            </tr>
            <tr>
                <td><span class="linkgen">foldl</span></td>
                <td><span class="linkgen">any</span></td>
                <td>Collapses the elements of a list, one by one, starting from the left-most element, into a single value using an arbitrary procedure.</td>
            </tr>
            <tr>
                <td><span class="linkgen">lambda</span></td>
                <td><span class="linkgen">proc</span></td>
                <td>Returns a new <span class="linkgen">procedure</span> with a specified set of parameters and body.</td>
            </tr>
            <tr>
                <td><span class="linkgen">map</span></td>
                <td><span class="linkgen">list</span></td>
                <td>Runs every member of a list (or set of members from a set of lists) through a given procedure and returns the list of results.</td>
            </tr>
            <tr>
                <td><span class="linkgen">ormap</span></td>
                <td><span class="linkgen">any</span></td>
                <td>Runs every member of a list (or set of members from a set of lists) through a given procedure or returns the logical OR of all of the results together.</td>
            </tr>
        </table>
        <h2>Detailed Descriptions:</h2><br>
        <h3 id="func-cons">cons</h3>
        <section>

            <pre class="sectionhead"><code>(cons <em>a</em> <em>b</em>)</code></pre>
            
            <a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28quote._~23~25kernel%29._cons%29%29" class="docs-link" target="_blank"></a>
            <h4>Main Overview</h4>
            <p>
                cons is a very simple function, but it's often misunderstood by first-timers because of a lack of the prerequisite knowledge of how pairs work in <span class="linkgen">Racket</span>. All that cons does is <em>cons</em>-truct a new pair with <code>a</code> as its first value and <code>b</code> as its second. Where the confusion arises is that we are often wanting to deal with <strong>lists</strong>, rather than pairs, and so cons behaves slightly differently than we might expect. Check out the FAQ on <span class="linkgen">pairs</span> for a more in-depth explanation.
            </p>

            <figure>
                <pre><code>(cons 1 2) <span class="note">-&gt; &apos;(1 . 2)</span>
(cons &apos;a &apos;b) <span class="note">-&gt; &apos;(a . b)</span>
(cons 1 &apos;()) <span class="note">-&gt; &apos;(1)</span>
(cons 1 &apos;(2 3)) <span class="note">-&gt; &apos;(1 2 3)</span>
(cons &apos;(1 2) 3) <span class="note">-&gt; &apos;((1 2) . 3)</span></code></pre>
            </figure>

        </section><br>
        <h3 id="func-lambda">lambda</h3>
        <section>

            <pre class="sectionhead"><code>(lambda (<i>args</i>) <i>body</i> ...)</code></pre>

            <a class="docs-link" href="https://docs.racket-lang.org/reference/lambda.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._lambda%29%29" target="_blank"></a>
            <h4>Main Overview</h4>
            <p>
                The lambda function is often people's first experience with <span class="linkgen">procedures</span>, that is, functions as data values. The name, lambda, comes from the <strong>Lambda Calculus</strong>, which is the formal mathematical system which originated the concept of doing operations on functions, and inspired the whole <span class="linkgen">Lisp</span> family of programming languages. So, that should give you an idea for how central this function is to everything we do in <span class="linkgen">Racket</span>.
            </p>
            <p>
                The lambda function is used to create a new procedure. The first parameter, <code>args</code> holds the names of the parameters that the procedure should accept. The second parameter, <code>body</code> holds the expression that the procedure should evaluate.
            </p>

            <figure>
                <pre><code><span class="comment">; Procedure which adds 5 to a value</span>
(lambda (x) (+ x 5)) <span class="note">-&gt; #&lt;procedure&gt;</span>

<span class="comment">; Procedure which takes the average of 2 numbers</span>
(lambda (a b) (/ (+ a b) 2)) <span class="note">-&gt; #&lt;procedure&gt;</span>

<span class="comment">; Applying a procedure immediately after creation with lambda</span>
(<span class="highlight">(lambda (x) (+ x 5))</span> 8) <span class="note">-&gt; 13</span>

<span class="comment">; Passing a procedure made with lambda as a parameter to another procedure</span>
(<span class="linkgen">map</span> <span class="highlight">(lambda (x) (+ x 5))</span> '(1 2 3 4)) <span class="note">-&gt; '(6 7 8 9)</span></code></pre>
            </figure>

            <h4>Optional Parameters</h4>
            <p>
                You can assign default values to parameters, which gives the user the option to skip passing in a value for that parameter. The parameter will then be filled in with whatever the default value is. The syntax looks like this:
            </p>

            <pre><code><span class="comment">; Procedure with one required parameter and one optional parameter</span>
(lambda (x [y 5]) (+ x y))

<span class="comment">; Applying that procedure without specifying a value for y</span>
(<span class="highlight">(lambda (x [y 5]) (+ x y))</span> 11) <span class="note">-> 16</span></code></pre>

            <p>
                Note that you must put all optional parameters at the end of your parameter list, after all required parameters, so that the order that parameters are passed in is always clear.
            </p>

            <figure>
                <pre><code><span class="comment">; Optional parameter before required parameter</span>
(lambda (x <span class="highlight">[y 5] z</span>) (+ x (+ y z))) <span class="error">-> SYNTAX ERROR</span></code></pre>
                <figcaption>What would happen if you called this procedure with 2 parameters? The program could eventually figure out that you meant to pass those values to x and z, but this gets less and less obvious to compute with bigger and more complicated arrangements. It's much more efficient to just have the restriction that all optional parameters come last.</figcaption>
            </figure>

            <h4>Trailing Bodies</h4>
            <p>
                If you have keen eyes you may have noticed the <code>...</code> in the definition of lambda and been wondering what that's all about. Well, as with most places that accept a code body, lambda will accept as many body expressions as you give it. These bodies will be executed one after another, and as is standard for Racket, the <em>last</em> body expression to be evaluated (also called <strong>tail position</strong>) will be the one that supplies the return value for the whole procedure.
            </p>

            <pre><code>(<span class="highlight">(lambda (x y) (println x) (println y) (+ x y))</span> 4 5)
<span class="output">&gt; 4&NewLine;&gt; 5</span>
<span class="note">-&gt; 9</span></code></pre>

        </section>
        <hr>
        <h3 id="func-define">define</h3>
        <section>

            <pre class="sectionhead"><code>(define <em>id</em> <em>expr</em>)
(define (<em>head</em> <em>args</em>) <em>body</em> ...)</code></pre>

            <a href="https://docs.racket-lang.org/reference/define.html#%28form._%28%28lib._racket%2Fprivate%2Fbase..rkt%29._define%29%29" class="docs-link" target="_blank"></a>
            <h4>Main Overview</h4>
            <p>
                You can think of the define function as <span class="linkgen">Racket</span>'s version of a global variable/function definition. Define is one of the few functions which does not have a return value. Instead, it is used to <span class="linkgen">bind</span> an identifier <code>id</code> to a value <code>expr</code>. Once bound, you'll be able to refer to that value later in your program using the name that it was bound to, just like when you define a variable in Java or C. However, these definitions cannot be changed, so they're closer to <strong>constants</strong> in other languages than variables.
            </p>

            <figure>
                <pre><code>(define myconstant 8)

(println myconstant)
<span class="output">&gt; 8</span></code></pre>
            </figure>

            <p>
                Of course, with the help of <span class="linkgen">lambda</span> or any other function that returns a <span class="linkgen">procedure</span>, you can also define functions this way! However, define also has an alternate syntax that is specifically for defining functions, which is kind of like a define and lambda combined. Instead of <code>id</code>, you specify the form that is to be used when calling the function, including its name and parameters. Then, as the second parameter you supply the body of the function. Below are examples of the same function being defined in Java syntax as well as both Racket syntaxes, for clarity:
            </p>

            <figure>
                <pre><code><span class="comment">// in Java</span>
public static var computeAverage(var x, var y)
{
    return (x + y) / 2.0;
}

<hr>
<span class="comment">; in Racket, with lambda</span>
(define compute-average <span class="highlight">(<span class="linkgen">lambda</span> (x y) (/ (+ x y) 2))</span>)

<span class="comment">; in Racket, with alternate define syntax</span>
(define (compute-average x y) (/ (+ x y) 2))</code></pre>
            </figure>

            <h4>Nested Function Definition</h4>
            <p>The alternate syntax of define has a bonus feature that may occasionally be useful if you can wrap your head around it. That is the ability to define <strong>nested functions</strong>. </p>

            <figure>
                <pre><code>(define ((increase-by x) y) (+ y x))

((increase-by 5) 4) <span class="note">-&gt; 9</span></code></pre>
            </figure>

            <p>
                To better understand what's going on, let's take another look at the define alternate syntax:
            </p>

            <figure>
                <pre><code>(define (<em>head</em> <em>args</em>) <em>body</em> ...)</code></pre>
            </figure>

            <p>
                What I neglected to point out before is that the <code>head</code> part of this definition is actually recursive. That is, you can replace <code>head</code> with another <code>(head args)</code> as many times as you want and the syntax will still be valid.
            </p>

            <figure>
                <pre><code>(define ((<em>head</em> <em>args</em>) <em>args</em>) <em>body</em> ...)
(define (((<em>head</em> <em>args</em>) <em>args</em>) <em>args</em>) <em>body</em> ...)
(define ((((<em>head</em> <em>args</em>) <em>args</em>) <em>args</em>) <em>args</em>) <em>body</em> ...)
...
in general:
<em>head</em> -> (<em>head</em> <em>args</em>) or <em>id</em></code></pre>
                <figcaption>If you're further along in your course, you may recognize that last line as a production rule for a context-free grammar.</figcaption>
            </figure>

            <p>
                What does this do though? Well, what's happening is it's defining a function which returns another function, which finally returns a value. It's as if the function <code>(increase-by x)</code> itself is the name of the main function <code>((increase-by x) y)</code>.
            </p>
            <p>
                This is all still just shorthand; it's nothing you couldn't achieve with the basic define syntax and some lambdas, as you can see demonstrated below:
            </p>

            <figure>
                <pre><code>; Function from the earlier example
(define ((increase-by x) y) (+ y x))

; The same function defined with basic syntax
(define increase-by (<span class="linkgen">lambda</span> (x) <span class="highlight">(<span class="linkgen">lambda</span> (y) (+ y x))</span>))</code></pre>
                <figcaption>Notice, the first lambda returns a second lambda!</figcaption>
            </figure>

            <p>
                Why would we want this? Well, the first syntax up above is much shorter and also clearer about the usage of the function that we're defining. As for why we'd want a nested function like that, there are times when we'd like to define a whole set of related functions, such as <code>increase-by-1</code>, <code>increase-by-10</code>, <code>increase-by-100</code> and this can be a neat and scalable way of doing so.
            </p>

            <figure>
                <pre><code>(define ((increase-by x) y) (+ y x))

(define (increase-by-1 y) (increase-by 1))
(define (increase-by-10 y) (increase-by 10))
(define (increase-by-100 y) (increase-by 100))

(println (increase-by-100 (increase-by-10 4)))
<span class="output">&gt; 114</span></code></pre>
                <figcaption>Of course, this is a pretty silly example since it would be easier just to use the built in <code>+</code> function, but imagine that the task we're trying to accomplish is a little more complex, like matrix multiplication. It would be convenient to just create a function that multiplies by a particular matrix if we know we're going to be doing it a lot. An alternative approach is to use <span class="linkgen">curry</span>.</figcaption>
            </figure>
        </section>
        <hr>
        <h3 id="func-map">map</h3>
        <section>
            <figure>
                <pre class="sectionhead"><code>(map <em><span class="linkgen">proc</span></em> <em>lst</em> ...)</code></pre>
            </figure>
            <a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._map%29%29" class="docs-link" target="_blank"></a>
            <h4>Main Overview</h4>
            <p>
                Map is one of the most fundamental operations that can be done with <span class="linkgen">procedures</span>. Its name comes from the terminology of <strong>set theory</strong>, where a map refers to a type of <strong>relation</strong> between two sets where every member of the input set is associated with exactly one member of the output set, much like how we associate points on the Earth's surface with points on a flat page when we draw geographical maps. The map function takes a procedure, and applies it in sequence to every member of a list, and then returns a list of the results in the same order.
            </p>
            <figure>
                <img src="./assets/figures/fig-map-1.svg" alt="An example expression, (map add1 '(0 2 6 8)), followed by a diagram showing how the input list of numbers are fed into the 'add1' function, represented as a box, and the corresponding outputs are sent to a new list, reading '(1 7 2 9).">
            </figure>
            <p>
                Map is a really useful tool to have at your disposal because in many cases it can greatly simplify things when you would otherwise need to write a loop to iterate through a list. Below are some examples of how you might use the map function:
            </p>
            <figure>
                <pre><code><span class="comment">; Generating the first 10 perfect square numbers</span>
(map sqr (range 10)) <span class="note">-&gt; &apos;(0 1 4 9 16 25 36 49 64 81)</span>

<span class="comment">; Running a logical test on each element of a list</span>
(map odd? &apos;(8 2 9 10 13 5 28)) <span class="note">-&gt; &apos;(#f #f #t #f #t #t #f)</span>

<span class="comment">; Appending a string to each element of a list of strings</span>
(map (<span class="linkgen">lambda</span> (s) (string-append &quot;P&quot; s))
     &apos;(&quot;ython&quot; &quot;erl&quot; &quot;HP&quot; &quot;ascal&quot; &quot;rolog&quot;))
<span class="note">-&gt; &apos;(&quot;Python&quot; &quot;Perl&quot; &quot;PHP&quot; &quot;Pascal&quot; &quot;Prolog&quot;)</span></code></pre>
            </figure>
            <h4>
                Multiple Input Lists
            </h4>
            <p>
                Map doesn't just work with procedures that have one input and one output. Notice the <code>...</code> in the function signature up above. Map can accept more than one input list, and if you supply additional ones, map will use them to fill in additional parameters in <code>proc</code>.
            </p>
            <figure>
                <pre><code><span class="comment">; a function that takes two parameters </span>
(* 4 3) <span class="note">-&gt; 12</span>

<span class="comment">; calling map with two input lists</span>
(map *
     &apos;(2 5 7 3)
     &apos;(8 4 3 9)) <span class="note">-&gt; &apos;(16 20 21 27)</span>

<span class="comment">; map will throw an error if the input lists</span>
<span class="comment">; don&apos;t all have the same number of elements</span>
(map *
     &apos;(2 5 7)
     &apos;(8 4 3 9))
<span class="error">-&gt; error: map: all lists must have the same size</span></code></pre>
            </figure>
        </section>
        <hr>
        <h3 id="func-andmap">andmap | ormap | foldl</h3>
        <section>
            <figure>
                <pre class="sectionhead"><code>(andmap <em><span class="linkgen">proc</span></em> <em>lst</em> ...)
(ormap <em><span class="linkgen">proc</span></em> <em>lst</em> ...)
(foldl <em><span class="linkgen">proc</span></em> <em>init</em> <em>lst</em> ...)</code></pre>
            </figure>
            <a href="https://docs.racket-lang.org/reference/pairs.html#%28def._%28%28lib._racket%2Fprivate%2Fmap..rkt%29._andmap%29%29" class="docs-link" target="_blank"></a>
            <h4>Main Overview</h4>
            <p>
                These three functions are variants of the <span class="linkgen">map</span> function. Like map, they too run a given <span class="linkgen">procedure</span> on every element of a given <span class="linkgen">list</span> (or set of lists). However, rather than a list, these functions combine the results of each call to <code>proc</code> to return a single value.
            </p>
            <p>
                <strong>andmap</strong> will return true if and only if <code>proc</code> returns true for every element of the list, and false otherwise.
            </p>
            <p>
                <strong>ormap</strong> will return true unless <code>proc</code> returns false for every element of the list, and false otherwise.
            </p>
            <p>
                <strong>foldl</strong> is a more general form of this operation and we'll discuss it further down.
            </p>

            <figure>
                <pre><code><span class="comment">; verify that every element of a list is an integer</span>
(andmap integer? &apos;(1 3 8 5 2)) <span class="note">-&gt; #t</span>
(andmap integer? &apos;(1 3 8 4.1 2)) <span class="note">-&gt; #f</span>

<span class="comment">; test if there exists an element of a list that is an integer</span>
(ormap integer? &apos;(3.8 7.4 &quot;x&quot; #f 200.9)) <span class="note">-&gt; #f</span>
(ormap integer? &apos;(3.8 8 &quot;x&quot; #f 200.9)) <span class="note">-&gt; #t</span>

<span class="comment">; test if the elements of two lists sum to 15 in each place</span>
(andmap (<span class="linkgen">lambda</span> (a b) (eq? (+ a b) 15))
        &apos;(1 2 3 4)
        &apos;(14 13 12 11)) <span class="note">-&gt; #t</span>

<span class="comment">; andmap and ormap are useful in evaluating the "for all"</span>
<span class="comment">; and "there exists" predicates of first order logic</span>

<span class="comment">; Test a given list, lst, for the condition:</span>
<span class="comment">; for all x in lst, there exists a, b in x for which a + b = 15</span>

(andmap
 (<span class="linkgen">lambda</span> (x)
   (ormap
    (<span class="linkgen">lambda</span> (a)
      (ormap
       (<span class="linkgen">lambda</span> (b)
         (eq? (+ a b) 15))
       x))
    x))
 lst)</code></pre>
            </figure>
            <h4>foldl</h4>
            <p>
                foldl is a more versatile form of <span class="linkgen">map</span>, andmap and ormap, giving you the freedom to specify how the values of the list(s) are combined. It takes an additional parameter called <code>init</code>. foldl starts from the left of the list (hence the "l") and calls <code>proc</code>, passing in the first element of the list along with <code>init</code> as parameters. It then passes the second element of the list along with the result of the first call to <code>proc</code> into the next call to <code>proc</code>, and then it passes the third element along with the result of that call into the next call, and on and on until it progresses through the whole list.
            </p>
            <p>
                I find it easiest to imagine the flow of foldl as if I was literally folding a brochure:
            </p>
            <figure>
                <img src="./assets/figures/fig-foldl-1.svg" alt="foldl is like the process of folding a brochure">
                <figcaption>The one inaccuracy with this image is that the result of the previous "fold" (or init in the first iteration) is passed as the right-most parameter to <code>proc</code>, rather than the left-most as depicted above.</figcaption>
            </figure>
            <p>
                foldl is a little less intuitive than the other functions in the <em>map</em> family, but it is incredibly powerful. Here are just a few examples of how it can be used:
            </p>
            <figure>
                <pre><code><span class="comment">; implementing a sum function using foldl</span>
(<span class="linkgen">define</span> (my-sum lst) (foldl + 0 lst))

<span class="comment">; implementing a reverse function using foldl</span>
(<span class="linkgen">define</span> (my-reverse lst) (foldl <span class="linkgen">cons</span> &apos;() lst))

<span class="comment">; implementing a map function using foldl</span>
(<span class="linkgen">define</span> (my-map proc lst) (foldl
                           (<span class="linkgen">lambda</span> (a b)
                             (append b (list (proc a))))
                           &apos;()
                           lst))

<span class="comment">; implementing an andmap function using foldl</span>
(<span class="linkgen">define</span> (my-andmap proc lst) (foldl
                              (<span class="linkgen">lambda</span> (a b) (and (proc a) b))
                              #t
                              lst))

<span class="comment">; implementing an ormap function using foldl</span>
(<span class="linkgen">define</span> (my-ormap proc lst) (foldl
                             (<span class="linkgen">lambda</span> (a b) (or (proc a) b))
                             #f
                             lst))

<span class="comment">; in the English card game of Cribbage, part of scoring</span>
<span class="comment">; a hand of cards involves counting the number of subsets of</span>
<span class="comment">; cards in the hand whose values add up to 15.</span>

<span class="comment">; Here is a Cribbage hand 15 counter using foldl:</span>
(<span class="linkgen">define</span> (count-15s card-values)
  (foldl
   (<span class="linkgen">lambda</span> (sublist tally)
     (if (eq? (foldl + 0 sublist) 15)
         (add1 tally)
         tally))
   0
   <span class="comment">; the combinations function returns all sublists of a list</span>
   <span class="comment">; AKA it takes the powerset</span>
   (combinations card-values)))

<span class="comment">; a pretty average Cribbage hand</span>
(count-15s &apos;(2 7 8 7 1 3 10)) <span class="note">-&gt; 4</span>

<span class="comment">; the theoretical perfect hand</span>
(count-15s &apos;(4 4 5 5 5 6 6)) <span class="note">-&gt; 13</span></code></pre>
                <figcaption>
                    There is also a <strong>foldr</strong> function, which, as you may have guessed, does the same thing as foldl but starts from the right of the list. It is unadvised to use foldr unless you have good reason, because it is actually more computationally expensive to iterate right-to-left through a list than it is to iterate left-to-right. This is because of the way lists are represented in Racket under the hood, which you can read about <a href="faq.html#what-are-pairs-and-lists">here</a>.
                </figcaption>
            </figure>
        </section>
        <hr>
        <h3 id="func-curry">curry</h3>
        <section>
            <figure>
                <pre class="sectionhead"><code>(curry <em><span class="linkgen">proc</span></em>)
(curry <em><span class="linkgen">proc</span></em> <em>v</em> ...)</code></pre>
            </figure>
            <a href="https://docs.racket-lang.org/reference/procedures.html#%28def._%28%28lib._racket%2Ffunction..rkt%29._curry%29%29" class="docs-link" target="_blank"></a>
            <h4>Main Overview</h4>
            <p>
                Currying is one of the more advanced standard operations in <span class="linkgen">functional programming</span> and it's named after mathematician Haskell Curry (who also has 3 different programming languages named after him). It describes the process of breaking down a <span class="linkgen">procedure</span> so that parameters can be fed to it one by one rather than all at once.
            </p>
            <p>
                When you call <code>curry</code> on a procedure, it returns a <em>curried</em> version of that procedure, which will behave exactly like the original procedure if it is called with the required number of parameters.
            </p>

            <figure>
                <pre><code><span class="linkgen">cons</span> <span class="note">-&gt; #&lt;procedure:cons&gt;</span>

(curry <span class="linkgen">cons</span>) <span class="note">-&gt; #&lt;procedure:curried:cons&gt;</span>

(<span class="linkgen">cons</span> 2 &apos;(6)) <span class="note">-&gt; &apos;(2 6)</span>

((curry <span class="linkgen">cons</span>) 2 &apos;(6)) <span class="note">-&gt; &apos;(2 6)</span></code></pre>
            </figure>

            <p>
                However, if you feed a curried procedure <em>fewer</em> parameters than it requires, it will <em>wait</em>, returning itself (to be precise, a version of itself that remembers the parameters you passed) until it recieves enough parameters, at which point it will finally execute.
            </p>

            <figure>
                <pre><code>(<span class="linkgen">define</span> (add-5-numbers a b c d e) (+ a b c d e))

((curry add-5-numbers) 1) <span class="note">-&gt; #&lt;procedure:curried:add-5-numbers&gt;</span>
(((curry add-5-numbers) 1) 2 3) <span class="note">-&gt; #&lt;procedure:curried:add-5-numbers&gt;</span>
((((curry add-5-numbers) 1) 2 3) 4) <span class="note">-&gt; #&lt;procedure:curried:add-5-numbers&gt;</span>
(((((curry add-5-numbers) 1) 2 3) 4) 5) <span class="note">-&gt; 15</span>

<span class="comment">; You can also pass in parameters with the initial call to curry</span>
((curry add-5-numbers 1 2 3 4) 5) <span class="note">-&gt; 15</span></code></pre>
                <figcaption>Note that this means curry can <strong>only</strong> be used with procedures that accept an exact number of parameters, because otherwise it would not know when to stop waiting.</figcaption>
            </figure>
            <figure>
                <img src="./assets/figures/fig-curry-1.svg" alt="curry if it was actually curry flowchart">
                <figcaption>Curry if it was actually curry...</figcaption>
            </figure>
            <h4>Example</h4>
            <p>
                So why is this useful? Well, there are often times in a program where you'd like to specify some parameters to a procedure before you specify others. Without curry, you would have to wait until you know every parameter you need to pass to the procedure, and this might mean jumping through a lot of hoops to make sure that all these values are accessible in the same scope. Let's take a look at an example.
            </p>
            <figure>
                <pre><code><span class="comment">; This function searches through a list of numbers and returns</span>
<span class="comment">; true if there exists a set of 3 numbers in the list that form</span>
<span class="comment">; a pythagorean triple (a^2 + b^2 = c^2).</span>
(<span class="linkgen">define</span> (contains-pythagorean-triple? A)
  (contains-pythagorean-triple?-helper A '()))

<span class="comment">; We accomplish this by creating a helper function which does all</span>
<span class="comment">; the real work and takes an additional parameter: "test-vals"</span>

<span class="comment">; test-vals will be used to store a list of the elements that</span>
<span class="comment">; are currently being tested for pythagorean triples. This is a</span>
<span class="comment">; pretty standard algorithm for finding particular subsets of a</span>
<span class="comment">; list of elements.</span>
(<span class="linkgen">define</span> (contains-pythagorean-triple?-helper A test-vals)
  (cond
    <span class="comment">; Once test-vals has amassed 3 elements, run them through</span>
    <span class="comment">; is-pythagorean-triple? and return the result.</span>
    [(= (length test-vals) 3)
     (is-pythagorean-triple?
      (first test-vals)
      (second test-vals)
      (third test-vals))]
    <span class="comment">; If we've reached the end of list A, return false.</span>
    [(empty? A) #f]
    <span class="comment">; Otherwise, we branch into two recursive calls:</span>
    <span class="comment">; One where we include (car A) in test-vals, and one</span>
    <span class="comment">; where we do not include (car A) in test-vals.</span>
    [else (or
           <span class="comment">; Case where we don't add (car A) to test-vals</span>
           (contains-pythagorean-triple?-helper
            (cdr A) test-vals)
           <span class="comment">; Case where we do add (car A) to test-vals</span>
           (contains-pythagorean-triple?-helper
            (cdr A) (<span class="linkgen">cons</span> (car A) test-vals))
           )]
    ))

<span class="comment">; Function to test if 3 numbers form a pythagorean triple</span>
(<span class="linkgen">define</span> (is-pythagorean-triple? a b c)
  (let ([a-squared (* a a)]
        [b-squared (* b b)]
        [c-squared (* c c)])
    (cond
      [(or
        (= (+ a-squared b-squared) c-squared)
        (= (+ c-squared a-squared) b-squared)
        (= (+ b-squared c-squared) a-squared)
        ) #t]
      [else #f]
      )))

<span class="comment">; Some example calls</span>
(contains-pythagorean-triple? &apos;(3 4 5)) <span class="note">-&gt; #t</span>
(contains-pythagorean-triple? &apos;(5 12 13)) <span class="note">-&gt; #t</span>
(contains-pythagorean-triple? &apos;(3 4 6 8)) <span class="note">-&gt; #f</span>
(contains-pythagorean-triple? &apos;(9 7 4 1 3 11 5)) <span class="note">-&gt; #t</span></code></pre>
            </figure>
            <p>
                Now, this code works just fine. It solves the problem at hand and pretty efficiently as well. However, it is a bit cumbersome having to keep track of this list of elements that we're testing. The following example shows the same function but utilizing curry. Notice how <code>test-vals</code> is nowhere to be seen; instead of having to manually keep track of the elements we're testing, we just immediately pass them into the curried version of <code>is-pythagorean-triple?</code>, which feels a lot cleaner.
            </p>
            <figure>
                <pre><code><span class="comment">; The same function but utilizing curry</span>
(<span class="linkgen">define</span> (contains-pythagorean-triple? A)
  (contains-pythagorean-triple?-helper
   <span class="comment">; We pass A to the helper function as before, but this time,</span>
   <span class="comment">; instead of passing an empty list for test-vals, we pass a</span>
   <span class="comment">; freshly curried version of is-pythagorean-triple?</span>
   A <span class="highlight">(curry is-pythagorean-triple?)</span>
   ))

(<span class="linkgen">define</span> (contains-pythagorean-triple?-helper A <span class="highlight">curried-test</span>)
  (cond
    <span class="comment">; Instead of that bulky expression from the previous example,</span>
    <span class="comment">; we just check whether curried-test has returned yet and pass</span>
    <span class="comment">; on the result if it has.</span>
    [<span class="highlight">(boolean? curried-test) curried-test</span>]
    [(empty? A) #f]
    [else (or
           <span class="comment">; Case where we don't pass (car A) to curried-test</span>
           (contains-pythagorean-triple?-helper
            (cdr A) <span class="highlight">curried-test</span>)
           <span class="comment">; Case where we do pass (car A) to curried-test</span>
           (contains-pythagorean-triple?-helper
            (cdr A) <span class="highlight">(curried-test (car A))</span>)
           )]
    ))</code></pre>
                <figcaption>The <code>is-pythagorean-triple?</code> function is not shown here because it's identical to the first example.</figcaption>
            </figure>
        </section>

    </main>
    <footer>
        <h2>Racket Explained</h2>
        <h3>References:</h3>
        <ul>
            <li>
                Graham, Hutton. "Frequently Asked Questions for comp.lang.functional". <a href="http://www.cs.nott.ac.uk/~pszgmh/faq.html">http://www.cs.nott.ac.uk/~pszgmh/faq.html</a>
            </li>
            <li>
                Official Racket Documentation. <a href="https://docs.racket-lang.org/">https://docs.racket-lang.org/</a>
            </li>
            <li>
                Lisp Programming Language Guide - History-Computer. <a href="https://history-computer.com/lisp-programming-language-guide/">https://history-computer.com/lisp-programming-language-guide/</a>
            </li>
            <li>
                Style Guide - Northeastern University, Khoury College of Computer Sciences, CS5010: Program Design Paradigms. <a href="https://course.ccs.neu.edu/cs5010sp15/style.html">https://course.ccs.neu.edu/cs5010sp15/style.html</a>
            </li>
            <li>
                Racket Logo. <a href="https://racket-lang.org/img/racket-logo.svg">https://racket-lang.org/img/racket-logo.svg</a>
            </li>
        </ul>
        <h3>Disclaimer</h3>
        <p>I've tried my best to ensure that the information displayed on this website is accurate and not misleading. If you notice inaccuracies or have any other suggestions feel free to <a href="https://forms.gle/ffUMm3LiwwdrK4dG8" target="_blank">contact me</a> and suggest an edit.</p>
    </footer>
</body>

</html>